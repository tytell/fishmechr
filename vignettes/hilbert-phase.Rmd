---
title: "hilbert-phase"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{hilbert-phase}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
# library(fishmechr)
devtools::load_all()
library(tidyverse)
library(patchwork)
```

# Using the Hilbert transform to estimate swimming kinematics

One convenient and relatively robust way to estimate body wavelength, wave speed, and bending frequency involves the use of the Hilbert transform $\mathbf{H}$, a procedure that uses the Fourier transform to estimate a periodic signal that is \qty{90}{\degree} shifted relative to another. In essence, given a cosine signal, the Hilbert transform returns the sine with the same amplitude and frequency. The utility of this operation is that it lets us estimate the ``analytic signal'', a complex-valued signal where the magnitude of the complex number is the amplitude of the wave and the phase angle of the complex number is the phase of the signal.

If a fish swims using a traveling wave of curvature $\kappa_s$ defined at a position $s$ along the body as
$$\kappa_s(t) = A_s(t) \cos\left(2\pi \left[ \frac{s}{\lambda} - f t \right] \right)$$
where $A_s(t)$ is the wave amplitude, $k$ is the wave length, $f$ is the oscillation frequency, and $t$ is time.

We can then take the Hilbert transform to estimate the analytic signal for curvature
$$\kappa^*_s(t) = \kappa_s(t) + i \mathbf{H}\{\kappa_s(t)\}$$
where $i$ is the imaginary number. (Note that the `hilbert` function returns the full analytic signal, not just the imaginary component as written above). For a complex number $C = a + ib$, the magnitude is denoted by $||C|| = \left[ a^2 + b^2 \right]^{1/2}$ and the phase angle is denoted by $\angle C = \tan^{-1} (b / a)$. 

This provides an estimate of the phase can be estimated as a continuous function of both time and position along the body. Other techniques for estimating phase require identifying particular features in the signal (such as peaks or zero crossings) and therefore do not estimate phase as a continuous signal. The estimated phase $\hat{\phi}$ is thus
$$\hat{\phi}_s(t) = \angle \kappa^*_s(t).$$
For a traveling wave, this phase, as estimated here, is equal to the argument of the cosine function from the traveling wave equation above, $\hat{\phi}_s(t) = 2\pi [s/\lambda - f t]$.

Therefore, we can use the estimated phase to compute the frequency and wavelength by taking derivatives in time or space, respectively,
$$\hat{f}(t) = \frac{1}{2\pi} \frac{\partial}{\partial t} \hat{\phi}_s(t)$$
$$\hat{\lambda}_s(t) = 2 \pi \left( \frac{\partial}{\partial s} \hat{\phi}_s(t) \right)^{-1}$$

The body wave speed $\hat{V}$ is the product of the two:
$$\hat{V}(t) = \hat{\lambda}_s(t) \hat{f}(t)$$

## Numerical considerations

The Hilbert transform only works well for this analysis with signals that are centered around zero and consist of many relatively smooth tailbeats. This is why we suggest using the curvature $\kappa$, rather than something like lateral position or the $y$ coordinate of the body. To use the Hilbert transform on a lateral position, it is important to subtract a baseline value or use a high pass filter to ensure that the signal is centered around zero.

Similarly, if the signal is noisy, the phase $\hat{\phi}$ will not increase steadily and the derivatives used to estimate $\hat{f}$ and $\hat{\lambda}$ will not be meaningful. It is best to filter the input signal using a bandpass or low pass filter so that the oscillations are smooth.

In most programming languages, one should use a function `atan2` to estimate phase (not `atan`), because it gives an angle that ranges around the full circle (rather than 0 to 180 degrees). However, the output of `atan2` will jump (usually from $\pi$ to $-\pi$) as $t$ or $s$ increase. To estimate frequency or wavelength, before performing the derivatives, one should estimate a smoothly increasing phase using a function `unwrap`, which searches for jumps and removes them.

## Arc length

Most kinematic variables are best specified in terms of arc length $s$, the distance along the body from the head to a particular point $i$:
$$ s_i = \sum_{j=2}^i \left[ (x_j - x_{j-1})^2 + (y_j - y_{j-1})^2 \right] $$
Using arc length is better than something like the $x$ coordinate for two reasons. First, often a fish does not swim precisely along the $x$ axis, which means that the points would need to be rotated. Second, many fish swim with relatively large amplitude motions, which means that the distance along the curve is larger than the distance along the swimming direction, particularly near the tail where amplitudes are higher.

## Estimating curvature

The 2D curvature $\kappa$ of the midline in the horizontal plane is often a useful variable to compute. It can be thought of in two different ways. First, it is the inverse of the radius of curvature: the radius of a circle drawn through three successive points. The smaller the radius of curvature, the sharper the body bend, and the larger the value of $\kappa$. This estimate for curvature is defined by the following equation
$$ \kappa = \left[ \frac{\partial x}{\partial s} \frac{\partial^2 y}{\partial s^2} - \frac{\partial y}{\partial s} \frac{\partial^2 x}{\partial s^2} \right] \left[ \left( \frac{\partial x}{\partial s} \right)^2 + \left( \frac{\partial y}{\partial s} \right)^2 \right]^{-3/2} $$

Second, it is the spatial derivative of the angle of each segment. If a segment at arc length $s$ has an angle $\theta$ to the horizontal axis, then the curvature is
$$ \kappa = \frac{\partial \theta}{\partial s} $$
The angle for segment $i$ is $\theta_i = \tan^{-1}(y_{i+1} - y_i, x_{i+1} - x_i)$.

Although both formulas are mathematically equivalent, they have slightly different properties depending on the measurement error on the $x$ and $y$ positions.

# Example analysis of a lamprey data set

The data set `lampreydata` is included in the `fishmechr` package. Most swimming kinematics
data sets should have a similar structure:
* A time or frame column. It's often good to keep both in the data set. (Here, these are in `t` and `frame`)
* A column that identifies the point on the body. This could be a factor variable, with names of each body part (like returned by Sleap or DeepLabCut), as long as there is a clear order from head to tail. Or it could be a numeric variable, with points numbered from 1 to $n$, where 1 is the snout and $n$ is the tail. (here this is in `point`).
* x and y coordinates of the point. Currently, these algorithms are only designed to work on 2D movements in the horizontal plane. (here these are in `mxmm` and `mymm`, indicating "midline" x and y points in mm)
  
```{r}
head(lampreydata)
```

This plot shows the midlines in two frames.
```{r}
lampreydata |> 
  filter(frame %in% c(10, 20)) |> 
  mutate(frame = factor(frame)) |> 
  ggplot(aes(x = mxmm, mymm, color = frame, group = frame)) +
  geom_path() +
  coord_fixed()
```

## Compute curvature

```{r}
lampreydata <-
  lampreydata |> 
  group_by(frame) |> 
  mutate(smm = arclength(mxmm, mymm),
         curve_ang = curvature(smm, mxmm, mymm),
         curve_xy = curvature(smm, mxmm, mymm, method="xy"))
```

```{r}
lampreydata |> 
  filter(frame %in% c(10, 20)) |> 
  mutate(frame = factor(frame)) |> 
  ggplot(aes(x = smm, color = frame, group = frame)) +
  geom_path(aes(y = curve_ang), linetype='solid') +
  geom_path(aes(y = curve_xy), linetype='dashed')
```
```{r}
lampreydata |> 
  filter(point %in% c(10, 18)) |>
  mutate(point = factor(point)) |> 
  ggplot(aes(x = t, y = curve_ang, color = point)) +
  geom_path()
```

```{r}
lampreydata <-
  lampreydata |> 
  group_by(point) |> 
  mutate(ph = hilbert_phase(curve_ang))
```


```{r}
lampreydata |> 
  ungroup() |> 
  filter(point %in% c(3, 8, 12, 16, 18)) |> 
  ggplot(aes(x = t, y = ph, color = point)) +
  geom_path(aes(group = point))
```

```{r}
lampreydata |> 
  group_by(point) |> 
  mutate(freq1 = get_frequency(t, ph, method='deriv'),
         freq2 = get_frequency(t, ph, method='slope')) |> 
  filter(point %in% c(3, 8, 12, 16, 18)) |> 
  ggplot(aes(x = t, y = freq1, color = point)) +
  geom_point() +
  geom_point(aes(y = freq2), shape=2)
```

```{r}
w <-
  lampreydata |> 
  filter(frame %in% c(50)) |> 
  group_by(frame) |> 
  mutate(ph2 = gsignal::unwrap(ph),
         wavelen1 = get_wavelength(smm, ph, method="deriv",
                                   ignore_s = \(s) s < 30),
         wavelen2 = get_wavelength(smm, ph, method="slope",
                                   ignore_s = \(s) s < 30),
         wavelen3 = get_wavelength(smm, ph, method="cycle",
                                   ignore_s = \(s) s < 30),
         wavelen4 = get_wavelength(smm, ph, method="halfcycle",
                                   ignore_s = \(s) s < 30))
w

p1 <- w |>  
  ggplot(aes(x = smm, y = ph2 / (2*pi), color = frame)) +
  geom_path()

p2 <- w |> 
  ggplot(aes(x = smm)) +
  geom_point(aes(y = wavelen1), color = 'black') +
  geom_point(aes(y = wavelen2), color = 'red') +
  geom_point(aes(y = wavelen3), color = 'green') +
  geom_point(aes(y = wavelen4), color = 'blue')

p1 / p2
```

